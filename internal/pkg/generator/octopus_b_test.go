package generator

import (
	"strconv"
	"strings"
	"testing"

	"github.com/mailru/activerecord/internal/pkg/arerror"
	"github.com/mailru/activerecord/internal/pkg/ds"
)

func TestGenerateOctopus(t *testing.T) {
	type args struct {
		params PkgData
	}

	namespaceNum := int64(2)
	namespaceStr := strconv.FormatUint(uint64(namespaceNum), 10)

	packageName := "foo"

	tests := []struct {
		name    string
		args    args
		want    *arerror.ErrGeneratorPhases
		wantStr map[string][]string
	}{
		{
			name: "simplePkg",
			want: nil,
			args: args{
				params: PkgData{
					ARPkg:      packageName,
					ARPkgTitle: "Foo",
					Indexes: []ds.IndexDeclaration{
						{
							Name:     "Field1",
							Num:      0,
							Selector: "SelectByField1",
							Fields:   []int{0},
							FieldsMap: map[string]ds.IndexField{
								"Field1": {IndField: 0, Order: 0},
							},
							Primary: true,
							Unique:  true,
						},
						{
							Name:     "Field2",
							Num:      1,
							Selector: "SelectByField2",
							Fields:   []int{1},
							FieldsMap: map[string]ds.IndexField{
								"Field1": {IndField: 1, Order: 0},
							},
							Primary: false,
							Unique:  false,
						},
					},
					FieldList: []ds.FieldDeclaration{
						{
							Name:       "Field1",
							Format:     "int",
							PrimaryKey: true,
							Mutators:   []ds.FieldMutator{},
							Serializer: []string{},
							ObjectLink: "",
						},
						{
							Name:       "Field2",
							Format:     "bool",
							PrimaryKey: true,
							Mutators:   []ds.FieldMutator{},
							Serializer: []string{},
							ObjectLink: "",
						},
					},
					FieldObject: map[string]ds.FieldObject{},
					Server:      ds.ServerDeclaration{Timeout: 500, Host: "127.0.0.1", Port: "11011"},
					Container:   ds.NamespaceDeclaration{Num: namespaceNum, PublicName: "Testmodel", PackageName: "testmodel"},
					Serializers: map[string]ds.SerializerDeclaration{},
					Imports:     []ds.ImportDeclaration{},
					Triggers:    map[string]ds.TriggerDeclaration{},
					Flags:       map[string]ds.FlagDeclaration{},
				},
			},
			wantStr: map[string][]string{
				"octopus": {
					`Code generated by argen. DO NOT EDIT.`,
					`func (obj *Foo) insertReplace(ctx context.Context, insertMode octopus.InsertMode) error {`,
					`func (obj *Foo) InsertOrReplace(ctx context.Context) error {`,
					`func (obj *Foo) Replace(ctx context.Context) error {`,
					`func (obj *Foo) Insert(ctx context.Context) error {`,
					`func (obj *Foo) Update(ctx context.Context) error {`,
					`func (obj *Foo) Delete(ctx context.Context) error {`,
					`func (obj *Foo) packPk() ([][]byte, error) {`,
					`func (obj *Foo) Equal (anotherObjI any) bool {`,
					`func (obj *Foo) PrimaryString() string {`,
					`func selectBox (ctx context.Context, indexnum uint32, keysPacked [][][]byte, limiter activerecord.SelectorLimiter) ([]*Foo, error) {`,
					`func (obj *Foo) SetField1(Field1 int) error {`,
					`func (obj *Foo) GetField1() int {`,
					`func UnpackField1(r *bytes.Reader) (ret int, errRet error) {`,
					`func packField1(w []byte, Field1 int) ([]byte, error) {`,
					`func NewFromBox(ctx context.Context, tuples []octopus.TupleData) ([]*Foo, error) {`,
					`func TupleToStruct(ctx context.Context, tuple octopus.TupleData) (*Foo, error) {`,
					`func New(ctx context.Context) *Foo {`,
					`func box(ctx context.Context, shard int, instType activerecord.ShardInstanceType) (*octopus.Connection, error) {`,
					`namespace uint32 = ` + namespaceStr,
					`type Foo struct {`,
					`package ` + packageName,
				},
				"mock": {
					`func (obj *Foo) mockInsertReplace(ctx context.Context, insertMode octopus.InsertMode) []byte {`,
					`func (obj *Foo) MockReplace(ctx context.Context) []byte {`,
					`func (obj *Foo) MockInsert(ctx context.Context) []byte {`,
					`func (obj *Foo) MockInsertOrReplace(ctx context.Context) []byte {`,
					`func (obj *Foo) MockUpdate(ctx context.Context) []byte {`,
					`func (obj *Foo) RepoSelector(ctx context.Context) (any, error) {`,
					`func SelectByField1MockerLogger(keys [], res FooList) func() (activerecord.MockerLogger, error) {`,
					`func (obj *Foo) MockSelectByField1sRequest(ctx context.Context, keys [], ) []byte {`,
					`func (obj *Foo) MockSelectResponse() ([][]byte, error) {`,
				},
			},
		},
		{
			name: "simpleProcPkg",
			want: nil,
			args: args{
				params: PkgData{
					ARPkg:      packageName,
					ARPkgTitle: "Foo",
					FieldList:  []ds.FieldDeclaration{},
					FieldMap:   map[string]int{},
					ProcFieldList: []ds.ProcFieldDeclaration{
						{
							Name:       "Input",
							Format:     "string",
							Type:       1,
							Serializer: []string{},
						},
						{
							Name:       "InputOutput",
							Format:     "string",
							Type:       2,
							Serializer: []string{},
						},
						{
							Name:       "Output",
							Format:     "string",
							Type:       3,
							Serializer: []string{},
						},
					},
					ProcFieldMap: map[string]int{},
					Server:       ds.ServerDeclaration{Timeout: 500, Host: "127.0.0.1", Port: "11011"},
					Container:    ds.NamespaceDeclaration{ObjectName: "bar", PublicName: "Testmodel", PackageName: "testmodel"},
					Indexes:      []ds.IndexDeclaration{{}},
					Serializers:  map[string]ds.SerializerDeclaration{},
					Imports:      []ds.ImportDeclaration{},
					Triggers:     map[string]ds.TriggerDeclaration{},
					Flags:        map[string]ds.FlagDeclaration{},
					AppInfo:      "",
				},
			},
			wantStr: map[string][]string{
				"octopus": {
					`Code generated by argen. DO NOT EDIT.`,
					`func (obj *Foo) GetOutput() string {`,
					`func (obj *Foo) GetInputOutput() string {`,
					`func Call(ctx context.Context, params FooParams) (*Foo, error)`,
					`func tupleToStruct(ctx context.Context, tuples []octopus.TupleData) (*Foo, error) {`,
					`func box(ctx context.Context, shard int, instType activerecord.ShardInstanceType) (*octopus.Connection, error) {`,
					`procName string = "bar"`,
					`type Foo struct {`,
					`type FooParams struct {`,
					`func (obj *FooParams) arrayValues() []string`,
					`package ` + packageName,
				},
				"mock": {
					`func (obj *Foo) mockInsertReplace(ctx context.Context, insertMode octopus.InsertMode) []byte {`,
					`func (obj *Foo) MockReplace(ctx context.Context) []byte {`,
					`func (obj *Foo) MockInsert(ctx context.Context) []byte {`,
					`func (obj *Foo) MockInsertOrReplace(ctx context.Context) []byte {`,
					`func (obj *Foo) MockUpdate(ctx context.Context) []byte {`,
					`func (obj *Foo) RepoSelector(ctx context.Context) (any, error) {`,
					//`func SelectByField1MockerLogger(keys [], res FooList) func() (activerecord.MockerLogger, error) {`,
					//`func (obj *Foo) MockSelectByField1sRequest(ctx context.Context, keys [], ) []byte {`,
					`func (obj *Foo) MockSelectResponse() ([][]byte, error) {`,
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ret, got := GenerateOctopus(tt.args.params)
			if got != tt.want {
				t.Errorf("GenerateOctopus() = %v, want %v", got, tt.want)
			}

			for name, strs := range tt.wantStr {
				buff, ex := ret[name]
				if !ex {
					t.Errorf("GenerateOctopus() Name %s not generated", name)
					return
				}

				for _, substr := range strs {
					if !strings.Contains(buff.String(), substr) {
						t.Errorf("GenerateOctopus() %s = %v, want %v", name, buff.String(), substr)
					}
				}
			}
		})
	}
}
