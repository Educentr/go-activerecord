package generator

import (
	"strings"
	"testing"

	"github.com/mailru/activerecord/internal/pkg/arerror"
	"github.com/mailru/activerecord/internal/pkg/ds"
)

func TestGenerateOctopus(t *testing.T) {
	type args struct {
		params PkgData
	}

	namespaceStr := "2"

	packageName := "foo"

	tests := []struct {
		name    string
		args    args
		want    *arerror.ErrGeneratorPhases
		wantStr map[string][]string
	}{
		{
			name: "fieldsPkg",
			want: nil,
			args: args{
				params: PkgData{
					ARPkg:      packageName,
					ARPkgTitle: "Foo",
					Indexes: []ds.IndexDeclaration{
						{
							Name:     "Field1",
							Num:      0,
							Selector: "SelectByField1",
							Fields:   []int{0},
							FieldsMap: map[string]ds.IndexField{
								"Field1": {IndField: 0, Order: 0},
							},
							Primary: true,
							Unique:  true,
							Type:    "int",
						},
						{
							Name:     "Field2",
							Num:      1,
							Selector: "SelectByField2",
							Fields:   []int{1},
							FieldsMap: map[string]ds.IndexField{
								"Field1": {IndField: 1, Order: 0},
							},
							Primary: false,
							Unique:  false,
							Type:    "bool",
						},
					},
					FieldList: []ds.FieldDeclaration{
						{
							Name:       "Field1",
							Format:     "int",
							PrimaryKey: true,
							Mutators:   []string{ds.IncMutator},
							Serializer: []string{},
							ObjectLink: "",
						},
						{
							Name:       "Field2",
							Format:     "bool",
							PrimaryKey: true,
							Mutators:   []string{},
							Serializer: []string{},
							ObjectLink: "",
						},
						{
							Name:       "Fs",
							Format:     "string",
							PrimaryKey: true,
							Mutators:   []string{"FsMutator"},
							Serializer: []string{},
							ObjectLink: "",
						},
					},
					FieldObject:   map[string]ds.FieldObject{},
					ServerConfKey: "testGenerateConfKey",
					Container:     ds.NamespaceDeclaration{ObjectName: "2", PublicName: "Testmodel", PackageName: "testmodel"},
					Serializers:   map[string]ds.SerializerDeclaration{},
					Mutators: map[string]ds.MutatorDeclaration{
						"FsMutator": {
							Name:       "FsMutator",
							Pkg:        "github.com/mailru/activerecord/internal/pkg/conv",
							Type:       "*parser_test.Foo",
							ImportName: "mutatorFooMutatorField",
							Update:     "updateFunc",
							Replace:    "replaceFunc",
							PartialFields: []ds.PartialFieldDeclaration{
								{Name: "Bar", Type: "ds.AppInfo"},
								{Name: "BeerData", Type: "[]Beer"},
								{Name: "MapData", Type: "map[string]any"},
							},
						},
					},
					Imports:  []ds.ImportDeclaration{},
					Triggers: map[string]ds.TriggerDeclaration{},
					Flags:    map[string]ds.FlagDeclaration{},
				},
			},
			wantStr: map[string][]string{
				"accessor": {
					`Code generated by argen. DO NOT EDIT.`,
					`func (obj *Foo) SetField1(Field1 int) error {`,
					`func (obj *Foo) GetField1() int {`,
				},
				"connection": {
					`Code generated by argen. DO NOT EDIT.`,
				},
				"index": {
					`Code generated by argen. DO NOT EDIT.`,
					`func (obj *Foo) packPk() ([][]byte, error) {`,
					`func (obj *Foo) PrimaryString() string {`,
				},
				"main": {
					`Code generated by argen. DO NOT EDIT.`,
					`func New(ctx context.Context) *Foo {`,
					`namespace uint32 = ` + namespaceStr,
					`type Foo struct {`,
					`func (obj *Foo) Equal(anotherObjI any) bool {`,
					`newObj.FsMutator.OpFunc`,
					`newObj.FsMutator.PartialFields`,
					`func NewFromBox(ctx context.Context, tuples []octopus.TupleData) ([]*Foo, error) {`,
					`func TupleToStruct(ctx context.Context, tuple octopus.TupleData) (*Foo, error) {`,
				},
				"mutators": {
					`Code generated by argen. DO NOT EDIT.`,
					`func (obj *Foo) packFsPartialFields(op activerecord.OpCode) error {`,
					`type Mutators struct {`,
					`func (obj *Foo) SetFsMutatorBar(Bar ds.AppInfo) error {`,
					`func (obj *Foo) SetFsMutatorBeerData(BeerData []Beer) error {`,
					`func (obj *Foo) SetFsMutatorMapData(MapData map[string]any) error {`,
					`func (obj *Foo) IncField1(mutArg int) error {`,
				},
				"pack": {
					`Code generated by argen. DO NOT EDIT.`,
					`func UnpackField1(r *bytes.Reader) (ret int, errRet error) {`,
					`func packField1(w []byte, Field1 int) ([]byte, error) {`,
				},
				"octopus": {
					`Code generated by argen. DO NOT EDIT.`,
					`package ` + packageName,
					`func selectBox(ctx context.Context, indexnum uint32, keysPacked [][][]byte, limiter activerecord.SelectorLimiter) ([]*Foo, error) {`,
					`func (obj *Foo) insertReplace(ctx context.Context, insertMode octopus.InsertMode) error {`,
					`func (obj *Foo) InsertOrReplace(ctx context.Context) error {`,
					`func (obj *Foo) Replace(ctx context.Context) error {`,
					`func (obj *Foo) Insert(ctx context.Context) error {`,
					`func (obj *Foo) Update(ctx context.Context) error {`,
					`func (obj *Foo) Delete(ctx context.Context) error {`,
				},
				"mock": {
					`func (obj *Foo) mockInsertReplace(ctx context.Context, insertMode octopus.InsertMode) []byte {`,
					`func (obj *Foo) MockReplace(ctx context.Context) []byte {`,
					`func (obj *Foo) MockInsert(ctx context.Context) []byte {`,
					`func (obj *Foo) MockInsertOrReplace(ctx context.Context) []byte {`,
					`func (obj *Foo) MockUpdate(ctx context.Context) []byte {`,
					`func (obj *Foo) RepoSelector(ctx context.Context) (any, error) {`,
					`func SelectByField1MockerLogger(keys []int, res FooList) func() (activerecord.MockerLogger, error) {`,
					`func (obj *Foo) MockSelectByField1sRequest(ctx context.Context, keys []int) []byte {`,
					`func (obj *Foo) MockSelectResponse() ([][]byte, error) {`,
					`func (obj *Foo) MockMutatorFsMutatorUpdate(ctx context.Context) [][]byte {`,
				},
				"fixture": {
					`type FooFT struct {`,
					`func MarshalFixtures(objs []*Foo) ([]byte, error) {`,
					`func UnmarshalFixtures(source []byte) []*Foo {`,
					`func (objs FooList) String() string {`,
				},
			},
		},
		{
			name: "simpleProcPkg",
			want: nil,
			args: args{
				params: PkgData{
					ARPkg:           packageName,
					ARPkgTitle:      "Foo",
					FieldList:       []ds.FieldDeclaration{},
					FieldMap:        map[string]int{},
					ProcInFieldList: []ds.ProcFieldDeclaration{},
					ProcOutFieldList: []ds.ProcFieldDeclaration{
						{
							Name:       "Output",
							Format:     "string",
							Type:       ds.OUT,
							Serializer: []string{},
						},
					},
					ServerConfKey: "testGenerateConfKey",
					Container:     ds.NamespaceDeclaration{ObjectName: "simpleProc", PublicName: "Testmodel", PackageName: "testmodel"},
					Indexes:       []ds.IndexDeclaration{},
					Serializers:   map[string]ds.SerializerDeclaration{},
					Imports:       []ds.ImportDeclaration{},
					Triggers:      map[string]ds.TriggerDeclaration{},
					Flags:         map[string]ds.FlagDeclaration{},
					AppInfo:       "",
				},
			},
			wantStr: map[string][]string{
				"mock": {
					`Code generated by argen. DO NOT EDIT.`,
					`func (obj *Foo) RepoSelector(ctx context.Context) (any, error) {`,
					`func CallMockerLogger(res FooList) func() (activerecord.MockerLogger, error) {`,
					`func MockCallRequest(ctx context.Context) []byte {`,
					`func (obj *Foo) MockSelectResponse() ([][]byte, error) {`,
				},
				"fixture": {
					`type FooFTPK struct {`,
					`type FooFT struct {`,
					`func MarshalFixtures(objs []*Foo) ([]byte, error) {`,
					`func UnmarshalFixtures(source []byte) []*Foo {`,
					`func (objs FooList) String() string {`,
				},
				"connection": {
					`Code generated by argen. DO NOT EDIT.`,
				},
				"main": {
					`Code generated by argen. DO NOT EDIT.`,
					`type Foo struct {`,
				},
				"proc": {
					`Code generated by argen. DO NOT EDIT.`,
					`func (obj *Foo) GetOutput() string {`,
					`func Call(ctx context.Context) (*Foo, error)`,
					`func TupleToStruct(ctx context.Context, tuple octopus.TupleData) (*Foo, error) {`,
					`type FooParams struct {`,
					`procName     string = "simpleProc"`,
				},
			},
		},
		{
			name: "procPkg",
			want: nil,
			args: args{
				params: PkgData{
					ARPkg:      packageName,
					ARPkgTitle: "Foo",
					FieldList:  []ds.FieldDeclaration{},
					FieldMap:   map[string]int{},
					ProcInFieldList: []ds.ProcFieldDeclaration{
						{
							Name:       "Input",
							Format:     "[]string",
							Type:       ds.IN,
							Serializer: []string{},
						},
						{
							Name:       "InputOutput",
							Format:     "string",
							Type:       ds.OUT,
							Serializer: []string{},
						},
					},
					ProcOutFieldList: []ds.ProcFieldDeclaration{
						{
							Name:       "InputOutput",
							Format:     "string",
							Type:       ds.OUT,
							Serializer: []string{},
						},
						{
							Name:       "Output",
							Format:     "string",
							Type:       ds.INOUT,
							Serializer: []string{"s2i"},
						},
					},
					ServerConfKey: "testGenerateConfKey",
					Container:     ds.NamespaceDeclaration{ObjectName: "bar", PublicName: "Testmodel", PackageName: "testmodel"},
					Indexes:       []ds.IndexDeclaration{},
					Serializers: map[string]ds.SerializerDeclaration{
						"s2i": {
							Name:        "Output",
							Pkg:         "github.com/mailru/activerecord/pkg/serializer",
							Type:        "int",
							ImportName:  "serializerOutput",
							Marshaler:   "OutputMarshal",
							Unmarshaler: "OutputUnmarshal",
						},
					},
					Imports:  []ds.ImportDeclaration{},
					Triggers: map[string]ds.TriggerDeclaration{},
					Flags:    map[string]ds.FlagDeclaration{},
					AppInfo:  "",
				},
			},
			wantStr: map[string][]string{
				"mock": {
					`func (obj *Foo) RepoSelector(ctx context.Context) (any, error) {`,
					`func CallMockerLogger(params FooParams, res FooList) func() (activerecord.MockerLogger, error) {`,
					`func MockCallRequest(ctx context.Context, params FooParams) []byte {`,
					`func (obj *Foo) MockSelectResponse() ([][]byte, error) {`,
				},
				"fixture": {
					`type FooFTPK struct {`,
					`type FooFT struct {`,
					`func MarshalFixtures(objs []*Foo) ([]byte, error) {`,
					`func UnmarshalFixtures(source []byte) []*Foo {`,
					`func (objs FooList) String() string {`,
				},
				"connection": {
					`Code generated by argen. DO NOT EDIT.`,
				},
				"main": {
					`Code generated by argen. DO NOT EDIT.`,
					`type Foo struct {`,
				},
				"proc": {
					`Code generated by argen. DO NOT EDIT.`,
					`func TupleToStruct(ctx context.Context, tuple octopus.TupleData) (*Foo, error) {`,
					`type FooParams struct {`,
					`func (obj *FooParams) arrayValues() ([]string, error)`,
					`procName     string = "bar"`,
					`func Call(ctx context.Context, params FooParams) (*Foo, error)`,
					`func (obj *Foo) GetOutput() int {`,
					`func (obj *Foo) GetInputOutput() string {`,
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ret, got := GenerateFromDir(tt.args.params, "octopus", OctopusTemplatesPath, tmplOctopusPath, OctopusTemplateFuncs)
			if got != tt.want {
				t.Errorf("GenerateOctopus() = %v, want %v", got, tt.want)
			}

			for name, strs := range tt.wantStr {
				buff, ex := ret[name]
				if !ex {
					t.Errorf("GenerateOctopus() Name `%s` not generated", name)
					continue
				}

				delete(ret, name)

				for _, substr := range strs {
					if !strings.Contains(string(buff), substr) {
						t.Errorf("GenerateOctopus() `%s`, can't find `%s` %s", name, substr, string(buff))
					}
				}
			}

			for name := range ret {
				t.Errorf("generated but not needed: %s", name)
			}

		})
	}
}
